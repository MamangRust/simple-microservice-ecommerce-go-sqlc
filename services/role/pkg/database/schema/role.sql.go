// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: role.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRole = `-- name: CreateRole :one
INSERT INTO
    roles (name, created_at, updated_at)
VALUES (
        $1,
        current_timestamp,
        current_timestamp
    )
RETURNING
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at
`

// CreateRole: Inserts a new role into the system
// Purpose: Add new role definitions (e.g., Admin, Cashier, etc.)
// Parameters:
//
//	$1: Role name
//
// Returns:
//
//	Newly created role's full data (including timestamps)
func (q *Queries) CreateRole(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, createRole, name)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentRoles = `-- name: DeleteAllPermanentRoles :exec
DELETE FROM roles WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentRoles: Permanently deletes all soft-deleted roles
// Purpose: Bulk cleanup of trashed roles
// Parameters: None
func (q *Queries) DeleteAllPermanentRoles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllPermanentRoles)
	return err
}

const deletePermanentRole = `-- name: DeletePermanentRole :exec
DELETE FROM roles WHERE role_id = $1 AND deleted_at IS NOT NULL
`

// DeletePermanentRole: Permanently deletes a trashed role
// Purpose: Remove role from DB after soft delete
// Parameters:
//
//	$1: Role ID
func (q *Queries) DeletePermanentRole(ctx context.Context, roleID int32) error {
	_, err := q.db.Exec(ctx, deletePermanentRole, roleID)
	return err
}

const getActiveRoles = `-- name: GetActiveRoles :many
SELECT
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at,
    COUNT(*) OVER () AS total_count
FROM roles
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR name ILIKE '%' || $1 || '%'
    )
ORDER BY created_at ASC
LIMIT $2
OFFSET
    $3
`

type GetActiveRolesParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveRolesRow struct {
	RoleID     int32            `json:"role_id"`
	Name       string           `json:"name"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	DeletedAt  pgtype.Timestamp `json:"deleted_at"`
	TotalCount int64            `json:"total_count"`
}

// GetActiveRoles: Retrieves only active (non-deleted) roles with optional search and pagination
// Purpose: Display roles that are currently usable in the system
// Parameters:
//
//	$1: Search query (nullable)
//	$2: Limit
//	$3: Offset
//
// Returns:
//
//	role_id, name, timestamps, and total_count
func (q *Queries) GetActiveRoles(ctx context.Context, arg GetActiveRolesParams) ([]*GetActiveRolesRow, error) {
	rows, err := q.db.Query(ctx, getActiveRoles, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveRolesRow
	for rows.Next() {
		var i GetActiveRolesRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at
FROM roles
WHERE
    role_id = $1
`

// GetRole: Retrieves role details by role_id
// Purpose: Fetch a single role record (regardless of deleted status)
// Parameters:
//
//	$1: Role ID
//
// Returns:
//
//	role_id, name, and timestamps
func (q *Queries) GetRole(ctx context.Context, roleID int32) (*Role, error) {
	row := q.db.QueryRow(ctx, getRole, roleID)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at
FROM roles
WHERE
    name = $1
`

// GetRoleByName: Retrieves role by exact role name
// Purpose: Check role existence or fetch role info based on name
// Parameters:
//
//	$1: Role name (exact match)
//
// Returns:
//
//	role_id, name, and timestamps
func (q *Queries) GetRoleByName(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getRoles = `-- name: GetRoles :many
SELECT
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at,
    COUNT(*) OVER () AS total_count
FROM roles
WHERE
    $1::TEXT IS NULL
    OR name ILIKE '%' || $1 || '%'
ORDER BY created_at ASC
LIMIT $2
OFFSET
    $3
`

type GetRolesParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetRolesRow struct {
	RoleID     int32            `json:"role_id"`
	Name       string           `json:"name"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	DeletedAt  pgtype.Timestamp `json:"deleted_at"`
	TotalCount int64            `json:"total_count"`
}

// GetRoles: Retrieves all roles (active & trashed) with optional name search and pagination
// Purpose: General listing of roles regardless of status
// Parameters:
//
//	$1: Search query (role name, nullable)
//	$2: Limit (number of records per page)
//	$3: Offset (starting index for pagination)
//
// Returns:
//
//	role_id, name, timestamps, and total_count (for pagination support)
//
// Business Logic:
//   - Supports fuzzy search on name
//   - Includes both active and trashed roles
//   - Useful for admin panels with filters and pagination
func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]*GetRolesRow, error) {
	rows, err := q.db.Query(ctx, getRoles, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRolesRow
	for rows.Next() {
		var i GetRolesRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedRoles = `-- name: GetTrashedRoles :many
SELECT
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at,
    COUNT(*) OVER () AS total_count
FROM roles
WHERE
    deleted_at IS NOT NULL
    AND (
        $1::TEXT IS NULL
        OR name ILIKE '%' || $1 || '%'
    )
ORDER BY deleted_at DESC
LIMIT $2
OFFSET
    $3
`

type GetTrashedRolesParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedRolesRow struct {
	RoleID     int32            `json:"role_id"`
	Name       string           `json:"name"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	DeletedAt  pgtype.Timestamp `json:"deleted_at"`
	TotalCount int64            `json:"total_count"`
}

// GetTrashedRoles: Retrieves only soft-deleted roles with optional search and pagination
// Purpose: For trash/recycle bin management
// Parameters:
//
//	$1: Search query (nullable)
//	$2: Limit
//	$3: Offset
//
// Returns:
//
//	role_id, name, timestamps, and total_count
func (q *Queries) GetTrashedRoles(ctx context.Context, arg GetTrashedRolesParams) ([]*GetTrashedRolesRow, error) {
	rows, err := q.db.Query(ctx, getTrashedRoles, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedRolesRow
	for rows.Next() {
		var i GetTrashedRolesRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.role_id, r.name, r.created_at, r.updated_at, r.deleted_at
FROM roles r
    JOIN user_roles ur ON ur.role_id = r.role_id
WHERE
    ur.user_id = $1
ORDER BY r.created_at ASC
`

// GetUserRoles: Retrieves all roles assigned to a specific user
// Purpose: Identify the access level(s) of a user
// Parameters:
//
//	$1: User ID
//
// Returns:
//
//	List of roles (id, name, timestamps)
func (q *Queries) GetUserRoles(ctx context.Context, userID int32) ([]*Role, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllRoles = `-- name: RestoreAllRoles :exec
UPDATE roles
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// RestoreAllRoles: Restores all soft-deleted roles in bulk
// Purpose: Bulk recovery of all trashed roles
// Parameters: None
func (q *Queries) RestoreAllRoles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, restoreAllRoles)
	return err
}

const restoreRole = `-- name: RestoreRole :one
UPDATE roles
SET
    deleted_at = NULL
WHERE
    role_id = $1
RETURNING
    role_id, name, created_at, updated_at, deleted_at
`

// RestoreRole: Restores a previously trashed role
// Purpose: Undelete a soft-deleted role
// Parameters:
//
//	$1: Role ID
func (q *Queries) RestoreRole(ctx context.Context, roleID int32) (*Role, error) {
	row := q.db.QueryRow(ctx, restoreRole, roleID)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashRole = `-- name: TrashRole :one
UPDATE roles
SET
    deleted_at = current_timestamp
WHERE
    role_id = $1
RETURNING
    role_id, name, created_at, updated_at, deleted_at
`

// TrashRole: Soft-deletes a role (moves to trash)
// Purpose: Mark role as deleted without removing it permanently
// Parameters:
//
//	$1: Role ID
func (q *Queries) TrashRole(ctx context.Context, roleID int32) (*Role, error) {
	row := q.db.QueryRow(ctx, trashRole, roleID)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    name = $2,
    updated_at = current_timestamp
WHERE
    role_id = $1
RETURNING
    role_id,
    name,
    created_at,
    updated_at,
    deleted_at
`

type UpdateRoleParams struct {
	RoleID int32  `json:"role_id"`
	Name   string `json:"name"`
}

// UpdateRole: Updates role name by ID
// Purpose: Modify role information (e.g., name correction)
// Parameters:
//
//	$1: Role ID
//	$2: New role name
//
// Returns:
//
//	Updated role's data
func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (*Role, error) {
	row := q.db.QueryRow(ctx, updateRole, arg.RoleID, arg.Name)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
