// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        firstname,
        lastname,
        email,
        password,
        verification_code,
        is_verified,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        current_timestamp,
        current_timestamp
    )
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Firstname        string `json:"firstname"`
	Lastname         string `json:"lastname"`
	Email            string `json:"email"`
	Password         string `json:"password"`
	VerificationCode string `json:"verification_code"`
	IsVerified       *bool  `json:"is_verified"`
}

// CreateUser: Creates a new user account
// Purpose: Register a new user in the system
// Parameters:
//
//	$1: firstname - User's first name
//	$2: lastname - User's last name
//	$3: email - User's email address (must be unique)
//	$4: password - Hashed password string
//
// Returns: The complete created user record
// Business Logic:
//   - Sets created_at and updated_at timestamps automatically
//   - Requires all mandatory user fields
//   - Email must be unique across the system
//   - Password should be pre-hashed before insertion
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.Password,
		arg.VerificationCode,
		arg.IsVerified,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentUsers = `-- name: DeleteAllPermanentUsers :exec
DELETE FROM users WHERE deleted_at IS NOT NULL
`

// DeleteAllPermanentUsers: Purges all trashed users
// Purpose: Clean up all soft-deleted user records
// Business Logic:
//   - Irreversible bulk deletion operation
//   - Only affects already soft-deleted users
//   - Typically used during database maintenance
//   - Should be restricted to admin users
func (q *Queries) DeleteAllPermanentUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllPermanentUsers)
	return err
}

const deleteUserPermanently = `-- name: DeleteUserPermanently :exec
DELETE FROM users WHERE user_id = $1 AND deleted_at IS NOT NULL
`

// DeleteUserPermanently: Hard-deletes a user account
// Purpose: Completely remove user from database
// Parameters:
//
//	$1: user_id - ID of user to delete
//
// Business Logic:
//   - Permanent deletion of already soft-deleted users
//   - No return value (exec-only operation)
//   - Irreversible action - use with caution
//   - Should trigger cleanup of related records
func (q *Queries) DeleteUserPermanently(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserPermanently, userID)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at FROM users WHERE email = $1 AND deleted_at IS NULL
`

// GetUserByEmail: Retrieves active user by email
// Purpose: Lookup user by email address (for authentication)
// Parameters:
//
//	$1: email - Exact email address to search for
//
// Returns: User record if found and active
// Business Logic:
//   - Case-sensitive exact match on email
//   - Excludes deleted users
//   - Used during login/authentication flows
//   - Helps prevent duplicate accounts
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserByEmailAndVerified = `-- name: GetUserByEmailAndVerified :one
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
FROM users
WHERE
    email = $1
    AND is_verified = true
    AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmailAndVerified(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailAndVerified, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at FROM users WHERE user_id = $1 AND deleted_at IS NULL
`

// GetUserByID: Retrieves active user by ID
// Purpose: Fetch specific user details
// Parameters:
//
//	$1: user_id - ID of user to retrieve
//
// Returns: Full user record if found and active
// Business Logic:
//   - Excludes deleted users
//   - Used for user profile viewing/editing
//   - Primary lookup for user management
func (q *Queries) GetUserByID(ctx context.Context, userID int32) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserByVerificationCode = `-- name: GetUserByVerificationCode :one
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at FROM users WHERE verification_code = $1
`

// - Filters the users table to find a user based on their verification code.
func (q *Queries) GetUserByVerificationCode(ctx context.Context, verificationCode string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByVerificationCode, verificationCode)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserTrashed = `-- name: GetUserTrashed :many
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at, COUNT(*) OVER () AS total_count
FROM users
WHERE
    deleted_at IS NOT NULL
    AND (
        $1::TEXT IS NULL
        OR firstname ILIKE '%' || $1 || '%'
        OR lastname ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
    )
ORDER BY created_at DESC
LIMIT $2
OFFSET
    $3
`

type GetUserTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetUserTrashedRow struct {
	UserID           int32            `json:"user_id"`
	Firstname        string           `json:"firstname"`
	Lastname         string           `json:"lastname"`
	Email            string           `json:"email"`
	Password         string           `json:"password"`
	VerificationCode string           `json:"verification_code"`
	IsVerified       *bool            `json:"is_verified"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
	TotalCount       int64            `json:"total_count"`
}

// GetUserTrashed: Retrieves paginated list of soft-deleted users
// Purpose: View and manage deleted users for potential restoration
// Parameters:
//
//	$1: search_term - Optional text to filter trashed users
//	$2: limit - Maximum records per page
//	$3: offset - Records to skip
//
// Returns:
//
//	Trashed user records with total_count
//
// Business Logic:
//   - Only returns soft-deleted records (deleted_at IS NOT NULL)
//   - Maintains same search functionality as active user queries
//   - Preserves chronological sorting (newest first)
//   - Used in user recovery/audit interfaces
//   - Includes total_count for pagination in trash management UI
func (q *Queries) GetUserTrashed(ctx context.Context, arg GetUserTrashedParams) ([]*GetUserTrashedRow, error) {
	rows, err := q.db.Query(ctx, getUserTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserTrashedRow
	for rows.Next() {
		var i GetUserTrashedRow
		if err := rows.Scan(
			&i.UserID,
			&i.Firstname,
			&i.Lastname,
			&i.Email,
			&i.Password,
			&i.VerificationCode,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at, COUNT(*) OVER () AS total_count
FROM users
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR firstname ILIKE '%' || $1 || '%'
        OR lastname ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
    )
ORDER BY created_at DESC
LIMIT $2
OFFSET
    $3
`

type GetUsersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetUsersRow struct {
	UserID           int32            `json:"user_id"`
	Firstname        string           `json:"firstname"`
	Lastname         string           `json:"lastname"`
	Email            string           `json:"email"`
	Password         string           `json:"password"`
	VerificationCode string           `json:"verification_code"`
	IsVerified       *bool            `json:"is_verified"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
	TotalCount       int64            `json:"total_count"`
}

// GetUsers: Retrieves paginated list of active users with search capability
// Purpose: List all active users for management UI
// Parameters:
//
//	$1: search_term - Optional text to filter users by name or email (NULL for no filter)
//	$2: limit - Maximum number of records to return (pagination limit)
//	$3: offset - Number of records to skip (pagination offset)
//
// Returns:
//
//	All user fields plus total_count of matching records
//
// Business Logic:
//   - Excludes soft-deleted users (deleted_at IS NULL)
//   - Supports partial text matching on firstname, lastname, and email fields (case-insensitive)
//   - Returns newest users first (created_at DESC)
//   - Provides total_count for client-side pagination
//   - Uses window function COUNT(*) OVER() for efficient total count
func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Firstname,
			&i.Lastname,
			&i.Email,
			&i.Password,
			&i.VerificationCode,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersActive = `-- name: GetUsersActive :many
SELECT user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at, COUNT(*) OVER () AS total_count
FROM users
WHERE
    deleted_at IS NULL
    AND (
        $1::TEXT IS NULL
        OR firstname ILIKE '%' || $1 || '%'
        OR lastname ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
    )
ORDER BY created_at DESC
LIMIT $2
OFFSET
    $3
`

type GetUsersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetUsersActiveRow struct {
	UserID           int32            `json:"user_id"`
	Firstname        string           `json:"firstname"`
	Lastname         string           `json:"lastname"`
	Email            string           `json:"email"`
	Password         string           `json:"password"`
	VerificationCode string           `json:"verification_code"`
	IsVerified       *bool            `json:"is_verified"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
	TotalCount       int64            `json:"total_count"`
}

// GetUsersActive: Retrieves paginated list of active users (identical to GetUsers)
// Purpose: Maintains consistent API pattern with other active/trashed endpoints
// Parameters:
//
//	$1: search_term - Optional filter text for name/email
//	$2: limit - Pagination limit
//	$3: offset - Pagination offset
//
// Returns:
//
//	Active user records with total_count
//
// Business Logic:
//   - Same functionality as GetUsers
//   - Exists for consistency in API design patterns
//
// Note: Could be consolidated with GetUsers if duplicate functionality is undesired
func (q *Queries) GetUsersActive(ctx context.Context, arg GetUsersActiveParams) ([]*GetUsersActiveRow, error) {
	rows, err := q.db.Query(ctx, getUsersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersActiveRow
	for rows.Next() {
		var i GetUsersActiveRow
		if err := rows.Scan(
			&i.UserID,
			&i.Firstname,
			&i.Lastname,
			&i.Email,
			&i.Password,
			&i.VerificationCode,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllUsers = `-- name: RestoreAllUsers :exec
UPDATE users
SET
    deleted_at = NULL
WHERE
    deleted_at IS NOT NULL
`

// RestoreAllUsers: Mass restoration of deleted users
// Purpose: Recover all trashed users at once
// Business Logic:
//   - Reactivates all soft-deleted users
//   - No parameters needed (bulk operation)
//   - Typically used during system recovery
//   - Maintains all original user data
func (q *Queries) RestoreAllUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, restoreAllUsers)
	return err
}

const restoreUser = `-- name: RestoreUser :one
UPDATE users
SET
    deleted_at = NULL
WHERE
    user_id = $1
    AND deleted_at IS NOT NULL
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

// RestoreUser: Recovers a soft-deleted user
// Purpose: Reactivate a previously deactivated user
// Parameters:
//
//	$1: user_id - ID of user to restore
//
// Returns: The restored user record
// Business Logic:
//   - Nullifies the deleted_at field
//   - Only works on previously deleted users
//   - Restores full account access
//   - Maintains all original user data
func (q *Queries) RestoreUser(ctx context.Context, userID int32) (*User, error) {
	row := q.db.QueryRow(ctx, restoreUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashUser = `-- name: TrashUser :one
UPDATE users
SET
    deleted_at = current_timestamp
WHERE
    user_id = $1
    AND deleted_at IS NULL
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

// TrashUser: Soft-deletes a user account
// Purpose: Deactivate user without permanent deletion
// Parameters:
//
//	$1: user_id - ID of user to deactivate
//
// Returns: The soft-deleted user record
// Business Logic:
//   - Sets deleted_at timestamp to current time
//   - Only processes currently active users
//   - Preserves all user data for potential restoration
//   - Prevents login while deleted
func (q *Queries) TrashUser(ctx context.Context, userID int32) (*User, error) {
	row := q.db.QueryRow(ctx, trashUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    firstname = $2,
    lastname = $3,
    email = $4,
    password = $5,
    updated_at = current_timestamp
WHERE
    user_id = $1
    AND deleted_at IS NULL
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	UserID    int32  `json:"user_id"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	Email     string `json:"email"`
	Password  string `json:"password"`
}

// UpdateUser: Modifies user account information
// Purpose: Update user profile details
// Parameters:
//
//	$1: user_id - ID of user to update
//	$2: firstname - Updated first name
//	$3: lastname - Updated last name
//	$4: email - Updated email address
//	$5: password - New hashed password (optional)
//
// Returns: Updated user record
// Business Logic:
//   - Auto-updates updated_at timestamp
//   - Only modifies active (non-deleted) users
//   - Validates email uniqueness
//   - Password field optional (can maintain existing)
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.UserID,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateUserIsVerified = `-- name: UpdateUserIsVerified :one
UPDATE users
SET
    is_verified = $2,
    updated_at = current_timestamp
WHERE
    user_id = $1
    AND deleted_at IS NULL
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

type UpdateUserIsVerifiedParams struct {
	UserID     int32 `json:"user_id"`
	IsVerified *bool `json:"is_verified"`
}

func (q *Queries) UpdateUserIsVerified(ctx context.Context, arg UpdateUserIsVerifiedParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserIsVerified, arg.UserID, arg.IsVerified)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET
    password = $2,
    updated_at = current_timestamp
WHERE
    user_id = $1
    AND deleted_at IS NULL
RETURNING
    user_id, firstname, lastname, email, password, verification_code, is_verified, created_at, updated_at, deleted_at
`

type UpdateUserPasswordParams struct {
	UserID   int32  `json:"user_id"`
	Password string `json:"password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.UserID, arg.Password)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Password,
		&i.VerificationCode,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
